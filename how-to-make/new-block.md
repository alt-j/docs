в разработке


----

Первый шаг мы сделали, создали страницу `test-page.page.js`, вот её содержимое:

```javascript
module.exports = function (pages) {
    pages.declare('index-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'index page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.js'}
            ],
            body: [
                // здесь ваши блоки
            ]
        };
    });
}
```

Мы ешё не умеем создавать блоки, давайте создадим первый, какой-нибудь несложный блок. Пусть это будет `input`.

Сразу вставим его вызов в `btjson` и обновим браузер:

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.js'}
            ],
            body: [
                {block: 'input'}
            ]
        };
    });
}
```

О, в браузере появился блок, хотя мы его даже не создавали:

```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>test page</title>
    <link rel="stylesheet" href="/build/test/_test.css">
</head>
<body class="page _init" data-block="page">
    <div class="input" data-block="input"></div>
    <script src="/build/test/_test.js" type="text/javascript"></script>
</body>
</html>
```

Шаблонизатор сам создал блок. Где-то внутри bt-шаблонизатора есть дефолтный шаблон,
который сгенерит html-тег для вашего блока, даже если вы сами не написали никакого шаблона.

Это бывает удобно, но не в нашем случае. Блок `input` должен быть представлен в `html` как тег `input`,
поэтому нам без своего шаблона не обойтись. И без стилей и без js-поведения нам не обойтись. Поэтому создадим сразу
нужные файлы блока

# Создаём файлы


В консоли прервём приложение сочетанием клавиш `Ctrl-C` или `Cmd-C` (если у вас
Mac OS). И воспользуемся инструментом для создания нового блока. Это небольшой bash-скрипт, который задаст вам один
вопрос, а после создаст сам блок:
```
make block
# Введите имя блока: input
```

На файловой системе появится директоряи файл `blocks/input`, а в ней сколько-то файлов.

Откройте файл  `blocks/input/input.bt.js` в редакторе:

```javascript
module.exports = function (bt) {

    bt.match('input', function (ctx) {
        ctx.setTag('span');

        ctx.setContent('Содержимое блока');
    });

};
```

У блока появился шаблон, который придумали мы, не вы. Это всё исправим, но сначала убедимся,
что новый шаблон наложился на блок `input`. Как это проверить? Обратите внимание,
в результате успешного наложения шаблона в `html` должен измениться тег, потому что в шаблоне есть два метода - один
меняет тег блоку, второй задаёт конент.

Было
```html
<div class="input" data-block="input"></div>
```

Должно стать
```html
<span class="input" data-block="input">'Содержимое блока'</span>
```

Опять запустим проект
```
make
```

Обновим в браузере `localhost:8080/test/` и откроеем `html`-код страницы. Ничего не произошло,
тег `div` не исчез, `span` вместо него не пояился, и контента нет и в помине.

Ошибка? Смотрим в консоль. Нет сообщений об ошибке. Значит, это не ошибка, мы что-то не сделали.

Мы не описали зависимость. Что такое зависимости, мы описали, [прочтите здесь](dependencies.md),
теперь самое удобное время это сделать. А если уже читали, тогда самое время добавить зависимость.

Коротко говоря, на странице `test` должен появиться блок `input`, следовательно страница "зависит" от блока.
Пока мы не сообщим странице эту зависимость, странце неоткуда брать информацию о том,
от которого она зависит.

----

Кажется, что декларации блоков в test-page.page.js вполне достаточно, чтобы сборщик понял,
от каких блоков зависит страница, но часты случаи, когда какой-то блок в своих шаблонах декларирует друго йблок,
вложенный - мы увидим это на примере ниже. В таких случаях обход всех шаблонов и анализ данных обойдётся "дорого" -
сборка проекта ощутимо замедлится, кодовая база бивис-движка заметно увеличится.

Мы не приветствуем такие сайдэффекты, елси они не жизненно необходимы. В случае с декларацией блоков польза мала,
а вред большой. Поэтому мы явно указываем странице, что она зависит от такого-то блока.

Дальше мы покажем, как блок вкладывать в блок и описывать зависимости между блоками с помощью того же механизма. Но
это позже, сейчас не обращайте внимания. Вообще-то вы уже читали об этом на странице [dependencies.md](dependencies
.md) ;)

----

Откройте файл `pages/test-page/test-page.deps.yaml`. В нём только одна строка

```
- page
```

Вы уже понимаете, что это значит. Что эта страница зависит от блока `page`. Потому что в декларации страницы мы
используем этот блок. Если мы решили использовать ещё и блок `input`, опишем и эту зависимость:

```
- page
- input
```

Обновите в браузере страницу и загляните в html. Успех? Мы видим, что шаблон отработал,
потому что html-кода блока изменился, как мы того и хотели:

```html
<span class="input" data-block="input">Содержимое блока</span>
```

Теперь напишем актуальный шаблон. Но перед этим мы предлагаем вам сделать очень важный шаг.

## Проектирование

На данном этапе полезно спроектировать блок.
Искусство проектирования может показаться нетривиальным и избыточным.
Но проектирование — это то, чем мы занимаемся в процессе разработки осознанно или неосознанно,
хотим мы того или не хотим. Делаем мы это в голове в виде мыслей или на бумаге в виде схем и диаграмм,
но каждый из нас этим занимается. Займёмся и мы.

Изобразим UML-диаграмму будущего блока. Это необязательно для вас, но мы сделаем,
чтобы явно показать ход наших мыслей.


Что умеет блок `input`? Пользователь вводит в него текст для того, чтобы форма отправила это значение на сервер.
То есть инпут должен уметь отдавать введённое значение.

Отобразим это в PlantUML-диаграмме с помощью простого описания:

```puml
class Input {
    +getValue(): String
}
```

Чтобы сделать из этого красивую картинку, отправляем этот код в http://www.plantuml.com/plantuml/form :
<img src="http://www.plantuml.com/plantuml/img/Iyv9B2vMyCmhA2rHgEPI00BjzDIIiCISqbGDJIk5u9AYpBnqhbe0" />
Теперь красиво и наглядно :)

Двигаемся дальше. Инпут ещё должен уметь принимать в себя значение, следовательно добавим в него метод-сеттер и
сделаем ещё одну красивую картинку:
<img src="http://www.plantuml.com/plantuml/img/Iyv9B2vMyCmhA2rHgEPI00BjzDIIiCISqbGDJIk5u9AYpBnqY7WnJBmCHCBaDBbg0G00" />

На этом остановимся, не будем раньше времени усложнять блок.

----

Скорее всего вы не проектируете свои приложения с помощью UML-схем. Мы бы тоже с удовольствием _не_ использовали эти
схемы ;)

Но нам трудно без таких формальных схем проектировать большие приложения, поэтому мы и коснулись этой темы. Если вам
будет это интересно знать, мы читали про UML на сайте
[http://plantuml.sourceforge.net/](http://plantuml.sourceforge.net/), а красивые картинки генерим
на сайте [http://www.plantuml.com/plantuml/form](http://www.plantuml.com/plantuml/form)

----

Что мы поняли, когда составили UML-схемуы?

Наш блок пока простой: значение из него можно получить, и можно значение установить.

Отлично, теперь мы готовы писать актуальный шаблон.

# Пишем актуальный шаблон
Шаблон должен
* Отобразать блок в виде тега `input`.
* Уметь принять в себя значение при генерации `html`

Попробуем набросать первый вариант.
Снова открываем файл `blocks/input/input.bt.js`. Пока он выглядит как заготовка:

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        ctx.setTag('span');

        ctx.setContent('Содержимое блока');
    });
};
```

Редактируем:

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        ctx.setTag('input');

        var currentValue = ctx.getParam('value');
        ctx.setAttr('value', currentValue);
    });
};
```

Разберём по-строчно.

```javascript
ctx.setTag('input');
```
Метод `setTag()` генерит в конечном `html` тег, заданный единственным параметром.


```javascript
var currentValue = ctx.getParam('value');
```
Метод `getParam()` принимает некий параметр "value" (откуда он, что за параметр - пока не важно) и сохраняет его
значение в локальную переменную `currentValue`.

```javascript
ctx.setAttr('value', currentValue);
```
Метод `setAttr()` генерит в конечном `html` атрибут, заданный первым параметром и устанавливает в атрибут строку,
переданную вторым параметром.

Сохраняем, рефрешим страницу, смотрим в `html`. Сработало, но не всё. Нет атрибута `value`

```html
<input class="input" data-block="input"></input>
```

Всё правильно, потому что метод `setAttr(attrName, attrValue)` создаёт атрибут только если второй параметр
`attrValue` не равен null. А у нас он как раз и равен null, потому что шаблон готов принять параметр,
а мы такой параметр ему не передали.

Передадим параметр. Смотрите, как у блока `input` появился параметр `value: 'Привет, Бивис'`

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.js'}
            ],
            body: [
                {
                    block: 'input',
                    value: 'Привет, Бивис'
                }
            ]
        };
    });
}
```

Теперь обновите страницу в браузере. Успех? :)

И в html оно выглядит так:
```html
<input class="input" data-block="input" value="Привет, Бивис"></input>
```
Что за поле ввода без атрибута `name`? Как форма передаст его значение на сервер? Тогда добавим ещё один атрибут. Вы
уже знаете, можно было бы и не показывать как.

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        ctx.setTag('input');

        var currentValue = ctx.getParam('value');
        ctx.setAttr('value', currentValue);
        ctx.setAttr('name', 'loginField');
    });
};
```

И в html оно выглядит так:
```html
<input class="input" data-block="input" name="loginField" value="Привет, Бивис"></input>
```

Здесь мы захардкодили имя будущего атрибута. Не зазорно :)
Если мы точно знаем, что имя у инпута никогда не поменяется, почему бы и "не прибить гвоздём"?

А если серьёзно, то этим шагом мы не столько "хардкодим", сколько изолируем от внешнего мира внутреннее
устройство блока, никому не разрешаем извне передавать в инпут эту информацию. Ограничиваем API этого блока. И если
 мы делаем это сознательно по каким-то важным для нас причинам... почему бы и нет?

Вы можете делать API блока более открытым или... менее открытым. Это решать конкретно вам. Мы стараемся открывать
блок наружу только самым минимальным образом, потому что в этом случае мы сохраняем максимальный контроль над
внутренним устройством блока.

Например, сейчас мы выливаем шаблоном тег `input`, а вдруг завтра окажется, что вокруг тега `input` нужна обёртка из
тега `div`. Так как блок имеет  максимально простое API (имя + минимум параметров),
мы можем как угодно менять `html`-реализацию — править существующий или писать новый шаблон,
который сгенерит вообще другой html. Важно лищшь, чтобы новые шаблоны обрабатывали тот самый минимум параметров.

На структуре мы пока остановимся, займёмся стилями.

## Стилизация

Откройте в редакторе файл `blocks/input/input.styl`, там написано:

```css
.input {
    /* здесь стили блока */
}
```

Напишите какое-нибудь свойство и обновите страницу в браузере. Я только что написал `border: 1px solid red;` и
проверил — у меня в браузере вокруг блока появилась рамка. У вас тоже успех?

В Stylus можно делать много разных вещей. Некоторые из них мы сознательно не используем. Точнее,
мы используем лишь некоторые, которые не смогут повредить стабильности стилей. Но это тема
[отдельного документа](css.md), там мы опишем подходы, которые мы себе разрешаем, и опишем вредные возможности,
которые мы себе строго запрещаем.

А вообще про Stylus стоит почитать на официальном
сайте [http://learnboost.github.io/stylus/](http://learnboost.github.io/stylus/)

Пока сделаем вид, что в `styl`-файлах мы пишем чистый `CSS` и перейдём к самому интересному

## Поведение

Добавим немного интерактивности.

Чтобы блок мог взаимодействовать с пользователем (или с другими блоками без участия пользователя),
необходимо сообщить Бивису, что этот блок интерактивный, что для него написано `js`-поведение.

Для этого мы пометим этот блок в дереве всех блоков страницы. Установим на нём "метку",
по которой бивис-движок поймёт, что для блока написано поведение.
блоке должны включить тумблер...

Делается это с помощью метода `enableAutoInit()`.

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        ctx.enableAutoInit();
        ctx.setTag('input');
        ctx.setAttr('value', ctx.getParam('value'));
        ctx.setAttr('name', 'loginField');
    });
};
```

Он включает инициализацию. А в действительности он сгенерит в html-коде специальный класс `_init`,
по которому бивис поймёт, что на этом блоке есть интерактивность.

```html
<input class="input _init" data-block="input" name="loginField" value="Привет, Бивис"></input>
```

Теперь запрограммируем поведение. Создайте файл `input.js` в директории `blocks/input` и скопируйте в него заготовку:

```javascript
modules.define(
    'input',
    ['inherit', 'block'],
    function (provide, inherit, YBlock) {
        var Input = inherit(YBlock, {
            // инстанс-методы
        }, {
            // статические методы
        });

        provide(Input);
    }
);
```

То, что мы видите, называется модуль. Модульных систем много разных, бивис использует
[Ymaps Modules](https://github.com/ymaps/modules/blob/master/what-is-this.md), которые придумали и разработали
разработчики из Яндекс.Карт. Пройдите по ссылке, прочитайте.
В основе модулей лежит очень простая идея, и в документации простым языком описывается,
зачем это нужно, как это использовать. И что конкретно означает каждая строчка из кода, который мы привели выше.

Не стали читать? ;) Там чтения на пять минут. Мы всё таки настаиваем, вам понравится.
[Прочитайте](https://github.com/ymaps/modules/blob/master/what-is-this.md)


Прочитали? Теперь вы понимаете, что код внутри анонимной функции - это и есть код,
который программрует поведение вашего `input`. Можно было бы программировать его по-старинке,
навешивая события на DOM-элементы самим или через jQuery-хелперы. Но мы предпочитаем работать с блоками через
абстракции, чтобы не зависеть от HTML-реализации блока.

Поэтому мы в зависимостях модуля `input` указали два других модуля — `inherit` и `block`.
Первый модуль возвращает функцию `inherit`, которая используется для создания классов и наследования (подробное
описание читайте на странице автора:
[https://github.com/dfilatov/node-inherit](https://github.com/dfilatov/node-inherit).

Второй модуль - это класс, который и реализует механизмы абстрагирования от DOM-узлов.
Это базовый визуальный блок. Все прочие визуальные блоки должны наследоваться от
этого блока с помощью модуля `inherit`.

В этом коде мы создаём класс `Input`, как наследника от класса `Yblock`, и пока больше ничего полезного не делаем.

```javascript
var Input = inherit(YBlock, {
    // инстанс-методы
}, {
    // статические методы
});
```

А этой строкой мы провайдим наш класс Input вовне, наружу. Предоставляем ручку из модуля,
за которую другие модули могут позвать его к себе через зависимости.

```javascript
provide(Input);
```

Ещё раз всё вместе с комментариями:

```javascript
modules.define(
    'input', // создали модуль, дали ему имя
    [
        'inherit', // зависимость от inherit
        'block' // зависимость от YBlock
    ],
    function (
        provide,
        inherit, // получаем функцию inherit
        YBlock // получаем блок YBlock
    ) {
        var Input = inherit(YBlock, {
            // здесь опишем инстанс-методы класса Input
        }, {
            // здесь опишем статические методы
        
            // при наследовании от YBlock, необходимо переопределить статический метод getBlockName
            getBlockName: function () {
                return 'input'; // вернуть необходимо имя блока
            }
        });

        provide(Input);
    }
);
```

А теперь собственно программный код для поведения блока.

```javascript
modules.define(
    'input',
    ['inherit', 'block'],
    function (provide, inherit, YBlock) {
        var Input = inherit(YBlock, {
            /**
             * @returns {String}
             */
            getValue: function() {
                return this.getDomNode().val();
            },
            /**
             * @param {String} value
             */
            setValue: function(value) {
                this.getDomNode().val(value);
            }
        }, {
            getBlockName: function () {
                return 'input';
            }
        });

        provide(Input);
});
```

Осталось убедиться, что все работает.

----

Подумать, как проиллюстрировать работу этого кода.

Показать через консоль Firebug?

----

# Нужны разные отображения?

Если дизайнер для разных форм сайта нарисовал разные текстовые поля,
есть смысл сделать два  отдельных представления этого блока, два `view`. У них будут разные стили,
но одинаковое поведение. Придумаем имена для представлений: `normal` и `active`.


Сначала добавим поддержку `view` в шаблоны.

Одно из отображений можно сделать умолчательным, например `normal`, потому что именно оно используется
 на всех страницах сайта, а `active` только на одной странице. Умолчательным (по дефолту,
 если говорить сленговым языком) означает, что в декларации блока не нужно указывать `view: 'normal'`,
 это вью будет добавляться автоматически.

Добавим перед вызов метода `bt.setDefaultView('input', 'normal')` и в шаблонах к имени блока добавим маску `*`

Было:

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        // ...
    });
};
```

Стало:

```javascript
module.exports = function (bt) {
    bt.setDefaultView('input', 'normal');

    bt.match('input*', function (ctx) {
        // ...
    });
};
```

Теперь шаблон отработает для блока с любым `view`, то есть для любого из нижеописанных вызовов:
```javascript
{
    block: 'input',
    view: 'normal',
    value: 'Hello'
}

// or

{
    block: 'input',
    view: 'active',
    value: 'Hello'
}

// или вообще без view, благодаря методу  bt.setDefaultView('input', 'normal')  подставится дефолтное значение

{
    block: 'input',
    value: 'Hello'
}

```

Проверям: не работает. Потому что нет зависимостей.

* зависимости для вью

Проверяем: работает. В html выливаются правильные классы.

Теперь расширяем стили

* два файла styl
* селекторы с вью
* общшие стили выносим в миксины скинов.

Проверяем - работает.

----

* Как обращаться за данными и передавать в блок?


* Подробнее о `YBlock`: [ссылка](yblock.md)
* Подробнее об `inherit`: [ссылка](https://github.com/dfilatov/inherit)


