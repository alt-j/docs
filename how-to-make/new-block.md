в разработке


----

Первый шаг мы сделали, создали страницу `test-page.page.js`, вот её содержимое:

```javascript
module.exports = function (pages) {
    pages.declare('index-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'index page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.js'}
            ],
            body: [
                // здесь ваши блоки
            ]
        };
    });
}
```

Мы ешё не умеем создавать блоки, давайте создадим первый, какой-нибудь несложный блок. Пусть это будет `input`.

Сразу вставим его вызов в `btjson` и обновим браузер:

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.js'}
            ],
            body: [
                {block: 'input'}
            ]
        };
    });
}
```

О, в браузере появился блок, хотя мы его даже не создавали:

```
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>test page</title>
    <link rel="stylesheet" href="/build/test/_test.css">
</head>
<body class="page _init" data-block="page">
    <div class="input" data-block="input"></div>
    <script src="/build/test/_test.js" type="text/javascript"></script>
</body>
</html>
```

Шаблонизатор сам создал блок. Где-то внутри bt-шаблонизатора есть дефолтный шаблон,
который сгенерит html-тег для вашего блока, даже если вы сами не написали никакого шаблона.

Это бывает удобно, но не в нашем случае. Блок `input` должен быть представлен в `html` как тег `input`,
поэтому нам без своего шаблона не обойтись. И без стилей и без js-поведения нам не обойтись. Поэтому создадим сразу
нужные файлы блока

# Создаём файлы


В консоли прервём приложение сочетанием клавиш `Ctrl-C` или `Cmd-C` (если у вас
Mac OS). И воспользуемся инструментом для создания нового блока. Это небольшой bash-скрипт, который задаст вам один
вопрос, а после создаст сам блок:
```
make block
# Введите имя блока: input
```

На файловой системе появится директоряи файл `blocks/input`, а в ней сколько-то файлов.

Откройте файл  `blocks/input/input.bt.js` в редакторе:

```javascript
module.exports = function (bt) {

    bt.match('input', function (ctx) {
        ctx.setTag('span');

        ctx.setContent('Содержимое блока');
    });

};
```

У блока появился шаблон, который придумали мы, не вы. Это всё исправим, но сначала убедимся,
что новый шаблон наложился на блок `input`. Как это проверить? Обратите внимание,
в результате успешного наложения шаблона в `html` должен измениться тег, потому что в шаблоне есть два метода - один
меняет тег блоку, второй задаёт конент.

Было
```html
<div class="input" data-block="input"></div>
```

Должно стать
```html
<span class="input" data-block="input">'Содержимое блока'</span>
```

Опять запустим проект
```
make
```

Обновим в браузере `localhost:8080/test/` и откроеем `html`-код страницы. Ничего не произошло,
тег `div` не исчез, `span` вместо него не пояился, и контента нет и в помине.

Ошибка? Смотрим в консоль. Нет сообщений об ошибке. Значит, это не ошибка, мы что-то не сделали.

Мы не описали зависимость. Что такое зависимости, мы описали, [прочтите здесь](dependencies.md),
теперь самое удобное время это сделать. А если уже читали, тогда самое время добавить зависимость.

Коротко говоря, на странице `test` должен появиться блок `input`, следовательно страница "зависит" от блока.
Пока мы не сообщим странице эту зависимость, странце неоткуда брать информацию о том,
от которого она зависит.

----

Кажется, что декларации блоков в test-page.page.js вполне достаточно, чтобы сборщик понял,
от каких блоков зависит страница, но часты случаи, когда какой-то блок в своих шаблонах декларирует друго йблок,
вложенный - мы увидим это на примере ниже. В таких случаях обход всех шаблонов и анализ данных обойдётся "дорого" -
сборка проекта ощутимо замедлится, кодовая база бивис-движка заметно увеличится.

Мы не приветствуем такие сайдэффекты, елси они не жизненно необходимы. В случае с декларацией блоков польза мала,
а вред большой. Поэтому мы явно указываем странице, что она зависит от такого-то блока.

Дальше мы покажем, как блок вкладывать в блок и описывать зависимости между блоками с помощью того же механизма. Но
это позже, сейчас не обращайте внимания. Вообще-то вы уже читали об этом на странице [dependencies.md](dependencies
.md) ;)

----

Откройте файл `pages/test-page/test-page.deps.yaml`. В нём только одна строка

```
- page
```

Вы уже понимаете, что это значит. Что эта страница зависит от блока `page`. Потому что в декларации страницы мы
используем этот блок. Если мы решили использовать ещё и блок `input`, опишем и эту зависимость:

```
- page
- input
```

Обновите в браузере страницу и загляните в html. Успех? Мы видим, что шаблон отработал,
потому что html-кода блока изменился, как мы того и хотели:

```html
<span class="input" data-block="input">Содержимое блока</span>
```

Теперь напишем актуальный шаблон. Но перед этим мы предлагаем вам сделать очень важный шаг.

## Проектирование

На данном этапе полезно спроектировать блок.
Искусство проектирования может показаться нетривиальным и избыточным.
Но проектирование — это то, чем мы занимаемся в процессе разработки осознанно или неосознанно,
хотим мы того или не хотим. Делаем мы это в голове в виде мыслей или на бумаге в виде схем и диаграмм,
но каждый из нас этим занимается. Займёмся и мы.

Изобразим UML-диаграмму будущего блока. Это необязательно для вас, но мы сделаем,
чтобы явно показать ход наших мыслей.


Что умеет блок `input`? Пользователь вводит в него текст для того, чтобы форма отправила это значение на сервер.
То есть инпут должен уметь отдавать введённое значение.

Отобразим это в PlantUML-диаграмме с помощью простого описания:

```puml
class Input {
    +getValue(): String
}
```

Чтобы сделать из этого красивую картинку, отправляем этот код в http://www.plantuml.com/plantuml/form :
<img src="http://www.plantuml.com/plantuml/img/Iyv9B2vMyCmhA2rHgEPI00BjzDIIiCISqbGDJIk5u9AYpBnqhbe0" />
Теперь красиво и наглядно :)

Двигаемся дальше. Инпут ещё должен уметь принимать в себя значение, следовательно добавим в него метод-сеттер и
сделаем ещё одну красивую картинку:
<img src="http://www.plantuml.com/plantuml/img/Iyv9B2vMyCmhA2rHgEPI00BjzDIIiCISqbGDJIk5u9AYpBnqY7WnJBmCHCBaDBbg0G00" />

На этом остановимся, не будем раньше времени усложнять блок.

----

Скорее всего вы не проектируете свои приложения с помощью UML-схем. Мы бы тоже с удовольствием _не_ использовали эти
схемы ;)

Но нам трудно без таких формальных схем проектировать большие приложения, поэтому мы и коснулись этой темы. Если вам
будет это интересно знать, мы читали про UML на сайте
[http://plantuml.sourceforge.net/](http://plantuml.sourceforge.net/), а красивые картинки генерим
на сайте [http://www.plantuml.com/plantuml/form](http://www.plantuml.com/plantuml/form)

----

Что мы поняли, когда составили UML-схемуы?

Наш блок пока простой: значение из него можно получить, и можно значение установить.

Отлично, теперь мы готовы писать актуальный шаблон.

# Пишем актуальный шаблон
Шаблон должен
* Отобразать блок в виде тега `input`.
* Уметь принять в себя значение при генерации `html`

Попробуем набросать первый вариант.
Снова открываем файл `blocks/input/input.bt.js`. Пока он выглядит как заготовка:

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        ctx.setTag('span');

        ctx.setContent('Содержимое блока');
    });
};
```

Редактируем:

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        ctx.setTag('input');

        var currentValue = ctx.getParam('value');
        ctx.setAttr('value', currentValue);
    });
};
```

Разберём по-строчно.

```javascript
ctx.setTag('input');
```
Метод `setTag()` генерит в конечном `html` тег, заданный единственным параметром.


```javascript
var currentValue = ctx.getParam('value');
```
Метод `getParam()` принимает некий параметр "value" (откуда он, что за параметр - пока не важно) и сохраняет его
значение в локальную переменную `currentValue`.

```javascript
ctx.setAttr('value', currentValue);
```
Метод `setAttr()` генерит в конечном `html` атрибут, заданный первым параметром и устанавливает в атрибут строку,
переданную вторым параметром.

Сохраняем, рефрешим страницу, смотрим в `html`. Сработало, но не всё. Нет атрибута `value`

```html
<input class="input" data-block="input"></input>
```

Всё правильно, потому что метод `setAttr(attrName, attrValue)` создаёт атрибут только если второй параметр
`attrValue` не равен null. А у нас он как раз и равен null, потому что шаблон готов принять параметр,
а мы такой параметр ему не передали.

Передадим параметр. Смотрите, как у блока `input` появился параметр `value: 'Привет, Бивис'`

```javascript
module.exports = function (pages) {
    pages.declare('test-page', function (params) {
        var options = params.options;
        return {
            block: 'page',
            title: 'test page',
            styles: [
                {url: options.assetsPath + '.css'}
            ],
            scripts: [
                {url: options.assetsPath + '.js'}
            ],
            body: [
                {
                    block: 'input',
                    value: 'Привет, Бивис'
                }
            ]
        };
    });
}
```

Теперь обновите страницу в браузере. Успех? :)

И в html оно выглядит так:
```html
<input class="input" data-block="input" value="Привет, Бивис"></input>
```
Что за поле ввода без атрибута `name`? Как форма передаст его значение на сервер? Тогда добавим ещё один атрибут. Вы
уже знаете, можно было бы и не показывать как.

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        ctx.setTag('input');

        var currentValue = ctx.getParam('value');
        ctx.setAttr('value', currentValue);
        ctx.setAttr('name', 'loginField');
    });
};
```

Здесь мы захардкодили имя будущего атрибута. Не зазорно :)
Если мы точно знаем, что имя у инпута никогда не поменяется, почему бы и "не прибить гвоздём"?

А если серьёзно, то этим шагом мы не столько "хардкодим", сколько изолируем от внешнего мира внутреннее
устройство блока, никому не разрешаем извне передавать в инпут эту информацию. Ограничиваем API этого блока. И если
 мы делаем это сознательно по каким-то важным для нас причинам... почему бы и нет?

Вы можете делать API блока более открытым или... менее открытым. Это решать конкретно вам. Мы стараемся открывать
блок наружу только самым минимальным образом, потому что в этом случае мы сохраняем максимальный контроль над
внутренним устройством блока.

Например, сейчас мы выливаем шаблоном тег `input`, а вдруг завтра окажется, что вокруг тега `input` нужна обёртка из
тега `div`. Так как блок имеет  максимально простое API (имя + минимум параметров),
мы можем как угодно менять `html`-реализацию — править существующий или писать новый шаблон,
который сгенерит вообще другой html. Важно лищшь, чтобы новые шаблоны обрабатывали тот самый минимум параметров.

На структуре мы пока остановимся, займёмся стилями.

## Стилизация

Для того, чтобы оформить блок, создадим файл `input.styl` в директории `blocks/input` со следующим содержимым:

```css
.input {
    border: #eee 1px solid;
}
```

Теперь наш блок обзавелся и оформлением.

Следует отметить, что мы используем CSS-препроцессор `stylus`. Подробнее о нем: http://learnboost.github.io/stylus/

## Поведение

Осталось наградить блок поведением.
Если поведение требуется для блока, необходимо установить флаг инициализации в шаблоне:

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        ctx.enableAutoInit();
        ctx.setTag('input');
        ctx.setAttr('value', ctx.getParam('value'));
    });
};
```

Теперь можно перейти и к JS-реализации блока. Создадим файл `input.js` в директории `blocks/common/input`.
Для начала следует декларировать модуль `input` в модульной системе:

```javascript
modules.define(
    'input', // имя модуля
    [], // зависимости
    function( // коллбек, который будет выполнен при удовлетворении зависимостей и загрузке модуля
        provide // функция, в которую необходимо передать содержимое модуля
    ) {
        provide(null); // передадим хоть что-нибудь
    }
);
```

Нам надо отнаследоваться от `YBlock` для того, чтобы наш класс стал визуальным блоком.
Наследоваться будем с помощью механизма `inherit`:

```javascript
modules.define(
    'input',
    [
        'inherit', // зависимость от inherit
        'y-block' // зависимость от YBlock
    ],
    function (
        provide,
        inherit, // получаем функцию inherit
        YBlock // получаем блок YBlock
    ) {
        var Input = inherit(YBlock, {
            // инстанс-методы
        }, {
            // статические методы
        
            // при наследовании от YBlock, необходимо переопределить статический метод getBlockName
            getBlockName: function () {
                return 'input'; // вернуть необходимо имя блока
            }
        });
        provide(Input);
    }
);
```

Осталось добавить необходимое поведение:

```javascript
modules.define('input', ['inherit', 'y-block'], function (provide, inherit, YBlock) {
    var Input = inherit(YBlock, {
        /**
         * @returns {String}
         */
        getValue: function() {
            return this.getDomNode().val();
        },
        /**
         * @param {String} value
         */
        setValue: function(value) {
            this.getDomNode().val(value);
        }
    }, {
        getBlockName: function () {
            return 'input';
        }
    });
    provide(Input);
});
```

Осталось убедиться, что все работает.

# Нужны разные отображения?

Если дизайнер для разных форм сайта нарисовал разные текстовые поля,
есть смысл сделать два  отдельных представления этого блока, два `view`. У них будут разные стили,
но одинаковое поведение. Придумаем имена для представлений: `normal` и `active`.


Сначала добавим поддержку `view` в шаблоны.

Одно из отображений можно сделать умолчательным, например `normal`, потому что именно оно используется
 на всех страницах сайта, а `active` только на одной странице. Умолчательным (по дефолту,
 если говорить сленговым языком) означает, что в декларации блока не нужно указывать `view: 'normal'`,
 это вью будет добавляться автоматически.

Добавим перед вызов метода `bt.setDefaultView('input', 'normal')` и в шаблонах к имени блока добавим маску `*`

Было:

```javascript
module.exports = function (bt) {
    bt.match('input', function (ctx) {
        // ...
    });
};
```

Стало:

```javascript
module.exports = function (bt) {
    bt.setDefaultView('input', 'normal');

    bt.match('input*', function (ctx) {
        // ...
    });
};
```

Теперь шаблон отработает для блока с любым `view`, то есть для любого из нижеописанных вызовов:
```javascript
{
    block: 'input',
    view: 'normal',
    value: 'Hello'
}

// or

{
    block: 'input',
    view: 'active',
    value: 'Hello'
}

// или вообще без view, благодаря методу  bt.setDefaultView('input', 'normal')  подставится дефолтное значение

{
    block: 'input',
    value: 'Hello'
}

```

Проверям: не работает. Потому что нет зависимостей.

* зависимости для вью

Проверяем: работает. В html выливаются правильные классы.

Теперь расширяем стили

* два файла styl
* селекторы с вью
* общшие стили выносим в миксины скинов.

Проверяем - работает.

----

* Как обращаться за данными и передавать в блок?


* Подробнее о `YBlock`: [ссылка](yblock.md)
* Подробнее об `inherit`: [ссылка](https://github.com/dfilatov/inherit)


