####Предисловие

Методология ли это? Я имею в виду `BEViS`. Методология? Ну, можно и так, если очень хочется. Но мы так не считаем.
"Методология" - затёртое до дыр понятие с десятком различных определений. Попробуй пойми, что имеет в виду автор WEB-фреймворка,
когда называет свой проект методологией: "Учение о методах и средствах познания мира", "Учение об организации абстрактной
деятельности" или вообще "Систему принципов и подходов научной исследовательской деятельности"?
Методология сейчас - модное наукообразное слово, которое ничего не помогает понять, а только вводит в заблуждение. Buzzword.

_Так что, нет, `BEViS` - не методология._

`BEViS` - эволюционная ветвь вёрстки `Абсолютно Независимыми Блоками`. Вы слышали о ней? Виталий Харисов, Яндекс, 2009 год — слышали?
Мы переосмыслили `АНБ` и поняли, как эту концепцию можно улучшить, как можно её упростить. Бивис в первую очередь - это соглашения об именовании тегов
 и  `CSS`-классов, о выделении логических частей внутри вашего сайта. Это рекомендации о том,
 как эффективно управлять  кодом вашего проекта. Эти рекомендации призваны упорядочить хаос из тегов,
 стилей и скриптов,  сделать ваш код стабильным, поддерживаемым и расширяемым.

`BEViS - это АНБ, но со строгим API`

Мы, разработчики `BEViS`, предлагаем вам думать о нашем продукте, так же, как вы думаете
о `Webkit`-е, когда изредка вспоминаете, что `Webkit` — это вообще-то форк почившего в бозе `KHTML`,
и даже не столько форк,  сколько его эволюционная ветвь, то есть нечто большее, чем был `KHTML` изначально,
нечто лучшее.  И смотрите, ещё какой нюанс. Про `Webkit` сейчас знают все. А кто из вас вспоминает про `KHTML`? А про `АНБ`? ;)

Но Бивис —  это не только какие-то бестелесные советы и рекомендации. Это ещё и готовые инструменты,
с которыми  сверстать полноценный динамический сайт может даже подросток. Для этого не нужно учить `PHP` или `Ruby`
или `Python`. Всё, что нужно для разработки полноценных сайтов на Бивисе, вы скорее всего знаете и так — `HTML`, `CSS`,
`Javascript`. Скажите, заманчиво? ;)

В добрый путь? :)

## Приложение

Как работает обычное веб-приложение? Это зависит от языка, но схематично это выглядит примерно у всех одинаково:

[Слайд](http://bevis-ui.github.io/bevis-and-bt-speech/?full#2)

Запрос из браузера попадает на некий `HTTP`-сервер. Это может быть `Apache` или `Nginx` или любой другой.
Запрос направляется в контроллер - программу, написанную, например, на `PHP` или на `Python`, которая
 получает данные из бекенда (из `MySql` или серванта), и передаёт в шаблоны представления, которые и генерят конечный `HTML`.

Эта схема известна каждому. Ну так мы её и не меняли. Мы поменяли технологии и шаблонизатор.

[Слайд](http://bevis-ui.github.io/bevis-and-bt-speech/?full#3)

Вместо `Apache` или `Nginx` у нас `Node.js`. Вместо `PHP` мы пишем программу на серверном `JS`, в которой обращаемся в сервант за данными,
накладываем на них шаблоны представления, которые тоже написаны на серверном `JS`, и отдаём пользователю конечный `html`.

Видите - схема та же. Только всё на яваскрипте, на серверном яваскрипте.

----

Зачем изобретать новый велосипед, если есть `Smarty`, есть `Django`, есть `XSLT`, в конце концов?

Две причины: простота и асинхронность. Простота в том, что сверстать приложение может любой школьник, который умеет на `HTML`/`CSS`/`JS`
Ему не нужно учить новый язык программирования - ни `PHP`, ни `Ruby`, ни `Python`. Что ещё учить не надо? `Perl`, `Java`, `C#`, `XSL`, продолжайте.
Я понимаю, что у каждого языка свои преимущества в определённых ситуациях. Но мы и не говорим, что они не нужны. Мы говорим,
 что типовые задачи веб-разработки можно успешно делать на серверном `JS`, который мы уже знаем.

И вторая причина - асинхронность. Для больших проектов важна скорость. Да и просто это модно, а мы ребята модные :)

Иными словами, мы захотели обрести полный контроль над фронтендом. Самое время! Есть все возможности!

----

Как выглядит наш контроллер `index.page.js?`
Это набор `JS`-команд. Так как мы пишем на `Node.js`, наш яваскрипт завернут в `Node.js` модули. И выглядит это примерно так:

```javascript
module.exports = function (pages) {

    pages.declare('index', function () {
        return {
            block: 'page',
            styles: 'index.css',
            scripts: 'index.js'
            body: [
                { block: 'header' },
                { block: 'authorization' }
            ]
        };
    });

};
```
Если вы на `Node.js` не писали, не пугайтесь, не обращайте внимания на первую строку. Относитесь к ней, как обвязке, без которой нельзя.
Всё интересное происходит внутри. А внутри обычный `JS`. Видите вызов функции `pages.declare()`?

В бивис-приложении есть объект `pages`, у которого есть метод `declare`.
В нём мы декларируем, что `index`-страница будет состоять из двух компонентов - из шапки и формы авторизации.
Выражаясь языком юристов, это "декларация о намерениях".

Это абсолютно валидный `JSON`. Совершенно обычный `JSON`. Бивис создавался, как фреймворк, который использует валидные нативные конструкции.
В этом `JSON` есть только одно служебное поле, оно называется `block`. Остальные поля можно называть как бог на душу положит.

Почему блок? Зачем какой-то `JSON`? И что оно вообще такое?

Подойдите вплотную к любой картине. Подойдите так близко, чтобы коснуться её носом. Что-то видно?
Хаос из цветных мазочков. Ни черта не разобрать.

[Слайд](http://bevis-ui.github.io/bevis-and-bt-speech/?full#5)

А теперь отойдите на несколько шагов и снова посмотрите на картину.
О! Так это же Шишкин Иван Иванович с его знаменитыми мишками в сосновом бору.

[Слайд](http://bevis-ui.github.io/bevis-and-bt-speech/?full#6)

И с вёрсткой так же. Когда мы получаем эскиз сайта от дизайнера, мы смотрим на него и
видим не теги, которые будет в `HTML`-файле. Мы видим какие-то абстракции. Ага - это будет шапка, это подвал, а тут форма авторизации.

Вы тоже, скорее всего, так делаете. Кто-то из вас называет такие абстракции модулями, кто-то компонентами или контролами.
Мы их называем `блоками`, потому что мы из Яндекса, а там родилась концепция верстки абсолютно независимыми блоками,
в которой впервые прозвучало слово `блок`. Ну и пусть, хороший же термин :)

А если вы не верстальщик, а настоящий программист, то вам станет яснее, когда я скажу, что блоком мы называем
примерно такую же абстракцию, как паттерн "Модуль" в `JS`.

Эдди Османи [говорит](http://largescalejs.ru/module-pattern/):
> «Модуль» — это популярная реализация паттерна, инкапсулирующего приватную информацию, состояние и структуру...


## Описание страницы обязано быть простым

Бивис-блок - это очень простая декларация на `JSON`. Простота - это очень важно.
Чем предмет проще, тем легче им пользоваться. Тем больше удовольствия от использования.

Бабушке моей жены восемьдесят девять лет. Она не любит покупной хлеб, печёт сама. Мы подарили бабушке хлебопечку, чтобы ей было легче.

Но она не пользуется!

Оказалось, пожилому человеку трудно запомнить
в какой последовательности какие кнопки нажимать - из инструкции старому человеку это
непонятно. Она по-прежнему пользуется газовой духовкой - куда проще - открыл дверцу, сунул тесто, закрыл дверцу.

Какой веб-фреймворк для верстки ни возьми, он в какой-то степени напоминает хлебопечку или пульт от телевизора.
Вы, кстати, обращали внимание, какими кнопками на пульте пользуется ваша бабушка? Только тремя: включить, сделать громче и переключить канал.

Мы с Маратом люди пожилые. И в отделе у нас работают ребята, которым уже за тридцать, а кому-то и под сорок, как мне :)
Нам это всё надоело. Надоело описывать страницу тегами, размечать их кастомными атрибутами. Это неоправданно сложно.
Слишком много суеты, слишком мало смысла.

Поэтому вот так, мы решили, должно выглядеть описание страницы. Максимально просто, максимально плоско.
```javascript
[
    { block: 'header' },
    { block: 'authorization' }
]
```

Здесь сказано, что на странице будет два блока - шапка и форма авторзации. 
Здесь нет ни одного тега, ни одного атрибута. Но такого описания достаточно, чтобы Бивис сгенерил полноценный
развесистый `HTML`, например такой:

```
<div class="header">
    <a class="header__logo" href="/">
        <img src="logo.png">
    </a> 
    <h1 class="header__title">Демо-страница</h1> 
    <h2 class="header__slogan">Слоган</h2> 
    <a class="header__rss" href="/?rss">
        <img src="rss.png">
    </a>
</div> 
<form class="authorization" action="/?task=login">
    <label class="authorization__label">Логин</label>
    <input class="authorization__login" value="">
    <label class="authorization__label">Пароль</label>
    <input class="authorization__password" 
        value="" type="password">
    <button class="authorization__submit">
        Войти
    </button>
</form>
```

Как мы этого добиваемся? Главное, что мы сделали - приняли закон, главенствующий приницип Бивиса.

####Чтобы пользоваться блоком, достаточно одного имени

Чтобы на странице оказался блок, о нём нужно знать только его имя и больше ничего. Вот... вообще ничего.

И эта та вещь в Бивисе, которой мы гордимся-гордимся.

И это очень похоже на реальную жизнь. Ведь,
когда я хочу позвать к себе в гости Марата, я делаю это очень просто - я зову его по имени и говорю: "Марат,
а приходи к нам в гости сегодня, жена яблочный пирог испечёт, посидим". А у Марата жена и двое детей,
к примеру. Я же не зову отдельно Марата, отдельно его жену и каждого ребенка по отдельности. Нет. Только его,
а уж он сам приведёт всё своё семейство, будьте уверены.
```javascript
{
    друг: 'Марат'
}
```

И с блоком так же. Когда я хочу, чтобы на станице появился какой-то блок, Я НЕ ХОЧУ думать, о том, из каких тегов и атрибутов он внутри устроен.

Ну, в самом деле, я когда в ресторан прихожу, и заказываю солянку, я же не даю указаний официанту: "Так, дорогуша, в солянке должно быть четыре кусочка картошки, 50 граммов салями,
мелко нарезанный солёный огурчик..." Нет. Я просто заказываю солянку. Ну, максимум, могут предложить: "Вам со сметаной?" Да, конечно, мне со сметаной:

```javascript
{
    суп: 'солянка',
    сметанаНужна: 'да'
}
```

То есть могут ещё задать какой-то дополнительный параметр. Но при этом, обратите внимание, и без сметаны суп можно есть. Просто с ней
возникает новый вкус.

Командир в окопе кричит сержанту: "Сержант Петренко, прикрыть правый фланг!".

```javascript
{
    сержант: 'Петренко',
    прикрыть: 'правый фланг'
}
```

Всё! Командир приказал — Петренко сделал. И пусть Петренко сам решает, как это делать — то ли вести самому автоматный огонь
в указанном направлении, то ли гранатами точку подавлять, то ли других бойцов послать штурмом фланг занять. Командиру
какое дело до этих деталей вообще?

Ну что, похоже на правду?

```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Пусть блоки сами решают, в какой `HTML` они должны превратиться, чтобы лучшим образом выполнить свою задачу.
Как они устроены внутри, я как пользователь блока, думать не хочу.

И за это я люблю Бивис. Создавать страницы из готовых блоков никогда ещё не было так просто.

####Блок - структура-представление-поведение

Да и сами блоки создавать тоже просто, потому что это очень жизненная абстракция.

Любое изобретение человека существует долго только в том случае, когда оно не противоречит законам природы.

Квадратное колесо, например, не прижилось, хотя человек пытался наладить его промышленный выпуск. Пытался. А почему не попытаться-то?
Квадратное легче производить, его удобнее транспортировать к точкам продажи. Но квадратное не может катиться. Это закон физической природы.

Всё, что создано человеком и смогло сохраниться веками - это то, что следует законам природы.

Блок, как божья тварь, состоит из трёх начал. Чтобы было понятнее, представьте меня в виде модуля, в виде блока:

1. У меня есть скелет, мышцы и внутренние органы. Это моя структура. У блока эту роль выполняет `HTML`-разметка.

2. У меня есть какой-то рост, вес, цвет кожи и выражение лица. Это мой внешний вид. У блока эту роль выполняют `CSS`-стили.

3. Я сейчас размахиваю руками и говорю с вами со сцены. Это моё поведение. Блок тоже умеет как-то взаимодействовать с пользователем на странице.

Меня можно позвать в гости, меня можно накормить солянкой, можно отослать меня в окоп.
Но при этом внутри себя я очень сложный. Кому-то пришлось потрудиться, чтобы я был таким, как есть.

И разработчику блока тоже нужно потрудиться. Чтобы мне в ресторане принесли солянку, нужно чтобы кто-то заранее её сварил, правильно?

Если я приду домой, и как в ресторане заявлю жене, что хочу на ужин борщ с фасолью и сметаной, знаете, что я услышу в ответ?

— Легко! Картошку почисть!

И я, кстати, не против. Жене по хозяйству нужно помогать. Я в этом убеждён твёрдо.

Чтобы в проекте появился блок, который легко позвать на страницу, нужно этот блок создать - его структуру, внешний вид и поведение. В Бивисе это делается легко.

### Императивные шаблоны

Как мы генерим `HTML` в смарти, джанго и других `MVC`?

Мы пишем шаблоны, которые выглядят, как `HTML`-код, в который точечно добавляются данные. Как будто шприцом обкалываем:
```html
<p>Уважаемый {{ person }}</p>
<p>Ваш заказ от {{ date:"F j, Y" }} принят на обработку.</p>
<p>Пожалуйста, убедитесь, что всё выбрано верно:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Гарантия - 12 месяцев.</p>
{% else %}
    <p>Со всеми неполадками обращайтесь в наш сервисный центр.</p>
{% endif %}
```

Я напомню, шаблоны эти пишутся в вот этом файле.

[слайд-схема с index.tpl.php]()

В бивисе мы решаем эту задачу с помощью декларативных шаблонов.

### Декларативные шаблоны

На `XSLT` писали? `XML` в `HTML` трансформировали? Тогда вы нас понимаете - шаблоны как в `XSLT`
А кто не писал на `XSL`, сейчас поймёте. Это легко.

Что это?

```css
h1 {
    color: red;
}
```

Даже школьник ответит: "Это `CSS`-селектор". Ну тогда поздравляем, вы умеете писать декларативные шаблоны.

`CSS`-селекторы - это пример самых настоящих декларативных шаблонов. Заголовок станет красным только тогда, когда он есть на странице. Если h1 на
странице нет, то и красить нечего, правда?

В этом вся соль декларативных языков программирования. Вместо инъекций шприцем (как в смарти-шаблонах) - только матчеры,
которые применяются к данным, если они есть. Это как горчичники - если есть куда их приложить - доктор их обязательно приложит.
Горчичники заматчатся или не заматчатся.

Предположим, наш контроллер выглядит так - на странице мы хотим видеть одну только шапку. Больше никаких блоков.

```javascript
module.exports = function (pages) {

    pages.declare('index', function () {
        return {
            block: 'header'
        }
    });
};
```

Фактически, мы видим декларацию только одного блока. Не смотрите на всю мишуру вокруг, сконцентрируйтесь только на этом `JSON`:

```javascript
{
    block: 'header'
}
```

Мы хотим, чтобы из этого `JSON`-а на странице появился такой `HTML`:
```html
<div class="header"></div>
```

Декларативный шаблон мог бы выглядеть почти, как в `CSS`

```javascript
header {
    tag: div;
}
```

Этот шаблон бы читался так: если на странице объявлен блок header, вылей для него тег div.
В реальности, мы почти так и пишем, только на чистом валидном `JS`:

Это шаблон на Бивисе:
```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Похоже на это, правда?
```javascript
header {
    tag: div;
}
```

Шаблон записывается в виде функции `match`, в которую мы первым параметром передаём имя блока.
А вторым аргументом пишем функцию, внутрь которой приходит исходный `btjson` в переменной `ctx`
А в функции сказано - создай тег `div`

Функция `match` - это метод шаблонизатора `bt`. `bt` - это и есть повар в ресторане или ваша жена на кухне.
У шаблонизатора прекрасная документация, которую поймёт даже школьник, почитайте.

Так что же такое "матчинг", наложение шаблонов?

В `CSS` такой шаблон вы знаете под именем "селектор" (от английского to select), потому что селектор как бы
выбирает блоки, к которым нужно применить стилевые свойства, а в других декларативных языках эта же
декларация зовётся "шаблоном" (трудно сказать почему). И ещё говорят, что шаблон матчится на
блок (от английского to match, что переводится, как "подбирать", "приводить в соответствие").
Кстати to select имеет те же самые значения, что и to match. То есть это равнозначные слова с одинаковым смыслом :)

Матчинг - это и есть селекция, выбор, проверка совпадения условий в селекторе (матчере).
То же самое, что вы делаете, когда пишете `CSS`-стили.

Только эти шаблоны вы пишете не в `CSS`-файле, а в `index.bt.js`.
Посмотрите ещё раз на схему, чтобы сориентироваться.
В SMARTy шаблоны хранятся в `index.tpl.php`, а у нас в `index.bt.js`

[Слайд](http://bevis-ui.github.io/bevis-and-bt-speech/?full#3)

А теперь вернёмся к шаблону
```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Он довольно бесполезный. Чтобы вылить тег, столько всего пришлось написать.
Давайте усложнять. Я хочу, чтобы внутри шапки появился заголовок.

Я добавил комментарии в код, чтобы вы всё поняли, а я помолчу.

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');

    // Генерим внутри шапки новый btjson и устанавливаем его, как содержимое шапки
    ctx.setContent({
        elem: 'title', // указываем элемент title в качестве содержимого
        text: 'CodeFest 2014' // произвольный текст для заголовка
    });
});

// регистрируем матчер для элемента title блока header
bt.match('header__title', function (ctx) {
    ctx.setTag('h1');

    // Получаем параметр text
    var text = ctx.getParam('text');

    // задаём содержимое заголовку
    ctx.setContent(text);
});
```

Результат:
```html
<div class="header">
    <h1 class="header__title">CodeFest 2014</h1>
</div>
```

Но это синтетический пример.
Ниже мы дадим вам ссылку на живой проект, который мы созадли специально, чтобы вы смогли его препарировать и изучать.

#### Это оверхед?
Сразу ответим на резонный вопрос: "Императивные шаблоны Смарти и Джанго привычные, понятные, их понимают все.
Почему мы не используем их?".

Императивные шаблоны остаются понятными, пока их немного.
Когда ваш проект разрастается, все больше и больше визуальных фрагментов переиспользуются, тогда шаблоны становятся сложными и запутанными.

В такой ситуации BT-шаблоны позволяют сохранять сложность на одном уровне.
Более того, BT-шаблоны позволяют нам иметь явный и понятный API каждого фрагмента страницы.

Наш подход хорош тем, что на странице нет описания того, КАК должен выглядеть блок, а только само указание, что "здесь есть такой-то блок и
у него такие-то параметры". Это же прям как в настоящем программировании - вызов класса с передачей в него параметров.
Класс выставляет наружу интерфейсные методы, которые не меняются и поддерживаются пожизненно, а внутрення реализация класса скрыта от глаз,
находится в приватной области.

Мы создали то же самое для `HTML`-верстки.

BTJson блока - это его внешнее АПИ блока, а BT-шаблоны - это приватная реализация блоков.

Ощутите мощь этой идеи на примере.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```
При такой простой декларации шапки, конечная `HTML`-верстка может какой угодно сложной.

```html
<div>тут добавить обычный `HTML` шапки</div>
```

Но самое ценное в том, что отныне можете менять шаблоны, генерирующие `HTML` как угодно часто, вам не нужно при этом переписывать
все страницы, и бояться, что на какой-то из них что-то пойдёт не так. АПИ блока гарантирует результат.

Возможно, кто из вас читал про Web Components.

Бивис реализует именно эту же идею. Но отличие в том, что Web Components пока ещё не
поддерживаются браузерами, а бивис вы можете использовать уже сегодня.

Кто-то может возразить, что мы пишем больше кода - каждый декларативный шаблон нужно явно описать, там задать какой тег выливать,
какие элементы внутри блока генерить. Ну так вы же на Смарти шаблонах тоже всё это пишете, только в виде чистого `HTML`. А мы пишем это на `JS`.

Вы скажете, что мы пишем куда больше букв и в доказательство приведёте эти две строки.
```javascript
ctx.setTag('div'); // 18 символов
```

```html
<div></div> <!-- 11 символов -->
```

Да, наша запись на семь символов длиннее, но только при условии, что вы руками пишете каждый символ, когда пишете теги.
Вы же не в `notepad.exe` код пишете, надеюсь?

Вы пользуетесь аутокомплитом, то есть написали открывающую скобку, затем букву `d` и нажали хоткей для аутокомплита.
Или если [Дзен-кодингом](http://pepelsbey.net/2008/08/zen-html/) набираете `HTML`, который придумал Вадим Макеев, а разработал Сергей
Чикуёнок, и теперь он называется [Emmet](http://emmet.io/), тогда вы вообще пишете три символа `div` и нажимаете `tab`.

Ну, а мы пользуемся сниппетами. Нажал хоткей, вписал только три символа `div` и у нас готова строка ```ctx .setTag ('div');```

Я веду к тому, что вы пишете императивные шаблоны, а мы декларативные, и прикладываем мы с вами сравнительно одинаковое количество сил для написания шаблонов.

## CSS блока

Имя у блока может быть простым — просто Марат, или просто Вадим, или просто header. Но бывают случаи, когда оно должно быть более точным.
Например, Марат Дулин, или Вадим Макишвили. Чтобы добавить в имя уникальности.

Кого из вас зовут Вадим?

Представьте, вы сидите в кино, и вдруг в дверь вбегает кто-то запыхавшийся и кричит на весь кинотеатр:
"Вадим, у тебя в продакшене 404 на главной странице!".

Сколько Вадимов встрепенётся и занервничает? Да, все Вадимы. Но если он крикнет "Вадим Макишвили", то
встрепенусь только я, а остальные Вадимы лишь недовольно оглянутся на шум.

Жизнь доказывает, что имени и фамилии достаточно для идентификации человека.

Когда мы зовём block: 'header', мы зовём наш блок по имени. Но если мы хотим добавить ещё больше уникальности, мы добавляем здесь
же "фамилию", которую у блока мы именуем словом `view`

```javascript
{
    block: 'header',
    view: 'search'
}
```

Читать это следует так: создай на странице шапку, да не простую, а поисковую.
Получится такой HTML:

```html
<div class="header_search">
    ....
</div>
```

Понимаете, блок один - шапка, но на одной странице она может быть поисковая, а на другой непоисковая.
Поэтому у неё есть два варианта отображения на странице, два представления, две темы, два скина, две шкурки...
два `View`. Разный вид одного и того же блока мы называем разным преставлением. Разным `View`.

Это вью активно используем когда пишем стили.

Теперь мы сделаем важное заявление, с которым кто-то из вас будет категорически несогласен.
Но тем интереснее, да? :)

Мы убеждены, что имя у блока должно быть одно. Мы не согласны с теми из вас, кто использует в верстке такой приём:

```
<div class="header authorization"></div>
```

Что это - шапка и форма авторизации одновременно? Это как? Я и папа, я и мама?

Вы смотрели фильм Георгия Данелия "Мимино"?

Мимино, главный герой фильма, грузинский летчик из горного селения. Играет Вахтанг Кикабидзе.
По сценарию Мимино захотел работать в большой авиации, прилетел в Москву, найти работу в Аэрофлоте. Жить ему негде, в гостиницах мест нет.
Это происходило во времена CCCP. Но знакомые знакомых договорились по блату поселить его в гостиницу, в которой как раз проводится всесоюзный слёт врачей-эндокринологов.
И чтобы Мимино заселили, ему нужно было на ресепшине солгать, что он тоже врач-эндокринолог.

И вот представьте. Мимино приходит в гостиницу. Синяя форма лётчика. Выглаженные стрелки на брюках. Погоны. Фуражка с эмблемой авиации.
И когда его удивлённо спрашивают "Вы, что — лётчик?", знаете, что он отвечает?

— Да. Иногда... Вообще-то, я эндокринолог.

Хороший летчик не может быть одновременно хорошим эндокринологом. Попробуй совмещать обе профессии - сплошные проблемы,
такова жизнь, не нам с ней спорить.

И в верстке с множественными именами у блоков сплошные хаос и боль, потому что в `CSS` нет надёжного механизма разруливания весов
у стилевых селекторов с одинаковой специфичностью: какой селектор позже записан, тот и применится к тегу.

Если для блока с `class="header authorization"` написать селектор `.header {border-color: red}`, а до него другой `.authorization {border-color: green}`,
то блок окажется окружён красным бордером. А если вдруг селекторы придут в обратном порядке - вокруг блока будет зелёный бордер.
А приходить они могут в разной последовательности, когда у вас динамическое построение `CSS`-файла.

Когда мы смешиваем два блока на одной `HTML`-ноде, нет способа влиять на эту ситуацию, нет возможности контролировать её.
Управлять ей. Точнее, он есть, но он вообще не гарантирует результат — надо повышать специфичность селекторов или загружать стилевые селекторы в "правильном" порядке,
собирать `CSS`-файл в "правильном" порядке.

А правильный — это какой? Как понять, в каком порядке, если есть возможность смешать два произвольных блока в произвольном порядке?
А если три блока? Или четыре? Количество сочетаний блоков на одной простой странице исчисляется тысячами.
Точно ли разработчик сможет учесть всё многообразие сочетаний? Сможет?

В `BEViS` мы отказались от смешивания блоков друг с другом. Нет миксов блоков на одной ноде - нет конфликтов.

#### Не смешивай несмешиваемое
Не знаю, как у вас в проектах, в Яндексе довольно часто можно встретить такие записи:
```html
<div class="button button_theme_normal button_shadow_yes">кнопка</div>
```

Есть некий базовый класс и несколько модификаторов, каждый добавляет к базовому классу что-то или переопределяет
какие-то стили из базового класса.

Чем это опасно?
Вы добавляете или изменяете какое-то свойство в одном из этих трёх классов, у вас нет никакой гарантии, что
ваши исправления не придут в конфликт весов со стилями других классов на этой ноде.

В большом проекте даже после небольших изменений в таких стилях хорошо бы перетестировать весь проект с нуля,
чтобы убедиться, что верстка не сломалась в тех блоках, где есть множественные классы. Проблема же в том, что нет
другого механизма, кроме ручного перебора каждой страницы. А если у вас Single Page Application, часть блоков не видна,
потому что строятся по данным, которые запрашиваются аякс... В-общем, верстка становится нестабильной.

И это совсем не похоже на независимые блоки. Какая же это независимость, если даже внутри одного блока могут
родиться проблемы отображения? Трудно себе даже представить потенциальные конфликты в стилях, если мы смешаем
два разных блока на одной ноде.

Что делает Бивис?
Мы в такой ситуации рассуждаем так: если в проекте нужна кнопка с темой normal и тенью, то должен существовать отдельный класс,
в котором сразу будет и тема normal и тень. В одном классе. Поэтому та запись с тремя классами превращается в один класс:

```html
<div class="button_normal-shadow">кнопка</div>
```

То есть мы делам блок button с `view: "normal-shadow"`. В `JSON` это записывается так:

```javascript
{
    block: 'button',
    view: 'normal-shadow'
}
```

А уже внутри этого вью мы смешиваем все эти разновидности кнопки и разруливаем все конфликты.
И делаем это с помощью препроцессора.

Кто сейчас не знает, что такое `CSS`-препроцессор? Все знают.

Кроме меня. Я относился к `CSS`-препроцессорам с брезгливостью. "Баловство это", — так я считал, — "Тот же `CSS`, только с синтаксическим сахаром."
А сахар я не люблю, кофе могу пить и несладкий.

Только оказалось, что сахар в препроцессорах - это не то, ради чего они нужны.
Мы с их помощью делаем верстку гибкой и модульной.

Как мы решаем задачу?

```css
skin-common() {
    /* общие стили для кнопки */
}

skin-theme-normal() {
    /* цветовая тема */
}

skin-shadow() {
    /* стили добавляют тень */
}

.button {
    skin-common()
    skin-theme-normal()
}

.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();
}
```

`skin-common()`, `skin-theme-normal()`, `skin-shadow()` - это так называемые миксины, примеси по-русски. Те же ``JS``-функции.

Мощь в том, что эти функции приватны. Они не попадают напрямую в скомпилироанный `CSS`-файл. Пока из конкретного селектора не вызову этот миксин, его содержимое нигде не светится
Я создаю селектор для нормальной кнопки с тенью, явно вставляю в него вызов нужных миксинов. Если между стилями возникли какие-то конфликты,
я их здесь же (всё ещё на сервере) разрулил, и в браузер пойдёт `CSS`-селетор, в котором полный порядок. 

Мы можем решить конфликты на этапе разработки, а не на этапе использования. В браузер пойдёт для этого блока один `CSS`-селектор. 
Гарантированно работающий.

```css
.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();

    /* а здесь разрулил все конфликты этих миксинов */
}
```

Идею так использовать препроцессор мы позаимствовали у Романа Комарова. Он предложил такую же схему для своего `CSS`-фреймворка Stylobat. Рома - это тот парень,
который является сейчас мейнтейнером препроцессора Stylus. Можно не стесняясь назвать его гениальным верстальщиком. 

Рома, спасибо тебе большое!

Что мы имеем на выходе: один блок имеет один `CSS`-класс. Мы по-прежнему утверждаем, что блок - это просто, одного имени достаточно.

## JS-поведение блока
Как мы пишем `JS` для блоков на странице?

В маленьких проектах мы делаем так:

```javascript
$( document ).ready(function() {

    var form = $('#my-form');
    form.submit(onSubmited);

    function onSubmited() {
        if ($('#my-form .button').hasClass('disabled')) {
            return false;
        }
    }

});
```

Для каждого блока мы описываем, что он должен делать.
Здесь же описываем реакции на пользовательские события.

В бивисе мы делаем то же самое, только не внутри ```$( document ).ready()```, а внутри модуля.

Модульные системы — это и `RequireJS`, и `CommonJS`.
Модуль - это очень простая идея. Это специальный `JS`-объект, внутрь которого мы вкладываем свой программный код. 
Ваш код будет работать, как и прежде, в нём ничего не меняется.

Модуль нужен только для того, чтобы обеспечить взаимодействие с другими фрагментами вашего кода, другими вашими модулями. 
Модуль, как кассир в Макдональдсе — когда он готов работать, он вскидывает руку: "Свободная касса!". 

Когда модуль загрузился в память, он сообщает об этом в модульную систему. И другие модули с этого момента могут использовать ваш 
код из этого модуля. Прям как по `domReady`.

У нас есть своя модульная система, она асинхронная на всех этапах своей работы.
Примерно так выглядит описание модуля в терминах модульной системы.

```javascript
modules.define(
    'form',
    ['jquery'],
    function(provide, $) {

        var form = $('#my-form');
        form.submit(onSubmited);

        function onSubmited() {
            if ($('#my-form .button').hasClass('disabled')) {
                return false;
            }
        }

        provide(form);
    }
);
```
Сам код остался тем же, обвязка немного поменялась.

Мы объявили модуль в первой строке.
Во второй мы дали модулю имя.
В третьей описали зависимости — в нашем случае это только `JQuery`
В четвёртой описали содержимое модуля. Именно в этой функции и происходит программирование поведения блока.
И пред-предпоследняя строка - это и есть вскинутая рука: "Свободная касса". Модуль form готов к работе. Так другие модули понимают, что могут использовать этот модуль

Обратите внимание, мы не используем напрямую `JQuery`.
Мы используем свой базовый класс для написания блоков. Это такой `JS`-класс,
который позволяет оперировать в `JS` именно нашими абстрактными блоками, а не тегами. Если нам надо найти блок, или элемент блока, мы делаем это не через dom-методы, типа `getElementById()`,
а нашими методами.

```javascript
modules.define(
    'form',
    ['button', 'input', 'y-block'],
    function(provide, button, input, YBlock) {

        var Form = inherit(YBlock, {
            __constructor: function () {
                this._submitButton = YButton.find(this);
                this._bindTo(this.getDomNode(), 'submit', this._onSubmited);

            },

            _onSubmited: function (e) {
                if (this._submitButton.isDisabled()) {
                    e.preventDefault();
                } else {
                    this.emit('submit');
                }
            }
        });

        provide(Form);
    }
);
```

Зачем оно такое надо? Модули и свой `JS`-класс для блоков? Почему не просто `jQuery`?

Во-первых, мы получаем код, который можно вновь и вновь использовать.

Во-вторых, мы получаем абстракцию над `HTML`-структурой блока. Нам не важно, как блок представлен на странице. Порой нам даже не важно, где он лежит - в body или в каком-то другом элементе.
Мы переходим от DOM-взгляда на компонент на другой. Мы смотрим на блоки с точки зрения семантики их работы.

И ещё это нужно, чтобы максимально разделить визуальное отображение и поведение. У Бивиса получилось.

Когда бивис сгенерит `HTML` для шапки, вы увидите там такое:
```html
<div
    class="header"
    data-block-name="header">
</div>
```
Слово `header`, записанное в атрибуте class участвует исключительно в стилях.
А то, что написано в `data-block` - именно по этому атрибуту Бивис находит шапку и назначает ей `JS`-поведение.

В бивисе блок может иметь один `CSS`-класс, а дата-атрибут совершенно другой. То есть вы можете спокойно удалить атрибут -
поведение вы потеряете, но внешний вид блока не сломается.

Едиственное место, где поведение и отображение пересекаются, это состояния блока. Этого никак не избежать, потому что и в жизни оно так устроено.

Когда я бегаю по стадиону, я краснею и потею. Меняется мой внешний вид. Когда я плаваю долго в море, кожа на пальцах сморщивается и бледнеет.
У нас есть знакомые, которые так определяют, можно ли ребенку ещё плавать в бассейне:

— Сын, у тебя там кожа на ладошках уже состарилась?

— Нет, пап, не состарилась!

А сам тем временем прячет за спину помятые ладошки.

В блоке тоже самое. Возьмём ту же форму авторизации. По нажатию на кнопку сабмита надо проверить поле логина. Если пустое - обвести поле
логина стыдливой красной рамкой. То есть изменить отображение блока, сменить его состояние с обычного на тревожное.

Из `JS` мы добавляем дополнительный класс, который отвечает за изменение внешнего вида в состоянии "тревога".

Вот что произойдёт в `HTML`-элементе блока
```html
<input class="login _unfilled" type="text"/>
```

а вот что мы заранее напишем в стилях
```css
/* обычное состояние */
.login {
    ...
}

/* тревожное состояние */
.login._unfilled {
    border: 1px solid red;
}
```

И когда мы на клиенте проверим, что поле логина пустое, мы добавим в ноду к инпуту класс "_unfilled"
Мы называем такие классы состояниями. State
Имя стейта может быть любым, какое вы выберете. Вам всего лишь нужно в стилях предусмотреть, что
если `JS` добавит такой-то стейт-класс, чтобы в отображении что-то изменилось.

Почему класс начинается с подчёркивания? Чтобы подчеркнуть, что он приватный для блока и чтобы легче его замечать.

Теперь понимаете, почему мы назвали наш подход BEViS?
```
B — [B]lock
E — [E]lement
Vi— [Vi]ew
S — [S]tate
```

## Сборка статики без боли

Мы почти закончили. Осталось сказать, что конечно же мы не пишем все стили в одном файле, все шаблоны в одном файле,
весь клиентский `JS` в одном файле. Каждый блок представлен на файловой системе своей папкой, это удобно и очень по-человечески.

Ведь у меня, как и у любого человека, есть дом — место, откуда я выхожу утром на работу и куда возвращаюсь каждый вечер.
Ну, хорошо, это не дом. Это квартира в многоэтажке.

У блока тоже есть свой дом - место, где блок отдыхает и ждёт, когда его "позовут поработать" в веб-странице.
В корне проекта есть директория `/blocks`, в ней живут все блоки. Только в ней. Это дом блоков. Не ищите других мест.
Если блока здесь нет, больше нет нигде.

````
/blocks
    /header
        header.bt.js
        header.styl
        header.js
    /form
        form.bt.js
        form.styl
        form.js
````

Каждый блок хранится в своей собственной папке, где шаблоны для генерации `HTML` описаны в `*.bt.js`, стили в `*.styl`, клиентский яваскрипт в `*.js`.
Эффективно, хотя и не ново. Когда моя дочка готовится к математике, она на парту выкладывает учебник по математике, тетрадь по математике,
угольник и карандаш — всё, что нужно именно для урока математики. У нас так же - всё, что нужно для блока находится в одной папке.

А когда учитель хочет проверить у всего класса домашнюю работу по математике, она ходит по рядам и собирает тетради в стопку.
У нас тоже есть такой сборщик. Когда в сервер приходит запрос на страницу, собирается не только `HTML`, но и `CSS`, и `JS`. Это всё делает
сборщик. Почему не Ant, Make, Grunt?

Сборка часто является узким местом в сложных компонентных системах, но в `BEViS` мы полностью интегрировали сборку в процесс разработки.
Работая над проектом достаточно лишь обновлять страницу в браузере, чтобы всегда видеть актуальные стили, скрипты и верстку. Но не по этой причине мы писали свой сборщик :)

Наш [ENB](https://github.com/enb-make/enb)-сборщик отличается огромной скоростью сборки для проектов с блочной структурой.
Он собирает проекты со скоростью пули. Вот та самая причина!

И теперь, когда мы знаем всё это, давайте посмотрим на схему. Давайте свяжем все ниточки в один клубок:

1. В адресную строку в браузере пользователь вводит `http://my-server.ru/`.

2. Браузер отправляет `HTTP`-запрос к серверу и ждёт.

3. ``Node.js``-сервер принимает запрос. Понимает, что нужно создать
страницу `index.html` и открывает на чтение файл `/pages/index/index.page.js`

4. Выполняет там `JS`-инструкции, а именно: ходит за данными в бекенд, формирует декларацию страницы из `btjson`,
анализирует каждый элемент `btjson`-массива и запоминает из каких блоков будет построена будущая `HTML`-страница.

5. После этого сервер запускает `ENB`-сборщик. На этом этапе, когда сервер
 принял запрос, `ENB` начинает с того, что создаёт пустые файлы
  * `/pages/index/index.styl`,
  * `/pages/index/index.js`,
  * `/pages/index/index.bt.js`

  Если такие файлы уже есть, `ENB` пропускает этот шаг и переходит к следующему.

6. Дальше `ENB` получает от сервера на вход имя первого блока — "header". `ENB` идёт на файловую систему проекта, находит директорию `/blocks/header` и заходит в неё.

7. Ищет файл `header.js`. Если он есть - копирует его содержимое в `/pages/index/index.js`. Делает то же самое для
`bt`-файла, создавая `/pages/index/index.bt.js`. А для стилей делает то же самое, только сначала запускает `Stylus`-компилятор,
который из `header.styl` генерит `CSS`-селекторы, а потом уже их копирует в `/pages/index/index.css`.

8. Дальше `ENB`  выходит из `/blocks/header` и заходит в следующий блок, объявленный в btjson, например в `/blocks/form` и делает то же самое. И так повторяется для всех блоков.

9. В результате работы сборщика файлы `index.bt.js`, `index.css`, `index.js`  заполнены `BT`-шаблонами,
`CSS`-селекторами и `JS`-скриптами, необходимыми для генерации `HTML` всех блоков на странице, для их стилизации и
для программирования `JS`-поведения. То есть `ENB` занимается тем, что создаёт страничные файлы.

10. Это почти всё, стилевой и яваскриптовый файлы готовы к отправке в браузер, но мы не можем пока отправлять, потому что у нас
не готов конечный `HTML` страницы. Поэтому `ENB` отключается, и контроллер `index.page.js` вызывает `BT`-шаблонизатор.

11. `BT` принимает из контроллера `btjson` и накладывает на него только что
сгенерённый `index.bt.js`, в результате чего происходит трансформация из `btjson`-а в
`HTML`-теги. В результате, в памяти сервера
формируется `HTML`-код страницы

12. Всё, это финал. `BT` создал `HTML`, `ENB` собрал `CSS` и `JS`. Сервер отправляет всё это назад в браузер по `HTTP`-протоколу.

13. И ура! В окне браузера у пользователя отобразилась наша страница.

Теперь вы точно представляете, как работает Бивис-приложение.

## Заключение

Начать работать на бивисе очень просто:
```
git clone git@github.com:bevis-ui/bevis-stub.git your-project
cd your-project
make
```
После этого мы открываем в браузере ```localhost:8080``` и говорим: "Привет, Бивис!"

Пользоваться бивисом нам радостно по нескольким причинам.

Во-первых, 99% бивиса - это простой `JS`.

Во-вторых, весь программный код покрыт юнит-тестами.

В-третьих, бивис написан в очень понятном кодстайле, которого придерживается команда Яндекс.Карт.

И самая главная причина: Бивис - это очень просто :)

На десерт мы приготовили для вас практикум. Есть сайтик, сверстанный на бивисе, в нём осталось
доверстать несколько блоков, стилизовать их и описать интерактивное поведение на странице.
Давайте [сделаем это вместе](practice.md)?
