https://github.com/ymaps/modules

Что это? Зачем и для кого? Как этим пользоваться?

На эти вопросы я давно хотел получить ответы, но стеснялся их задать. Спросить и прослыть тупицей? Дудки,
я лучше по-молчу. Если вы такой же робкий, этот документ именно для вас :)

Что это?
--------
Вы web-разработчик, пишете сайты; на страницах верстаете формочки с контролами,
различные компоненты, большие и маленькие; для большинства из них
пишете клиентский js-код? Вот и продолжайте это делать. Пока у вас нет своего кода,
модульная система вам не нужна. Никому не нужен пустой фантик без конфеты внутри.

Модуль - это фантик, в который вы заворачиваете свою конфету. На фантике написано имя конфеты и больше ничего. Вот вы
 и поняли, и что такое модуль. Оберните код пяти своих контролов каждый в свой отдельный фантик,
 у вас получится 5 модулей — система из пяти **ваших** модулей. Конфеты ссыпают в корзинку для сладостей,
 откуда  конфеты удобно таскать детям. Модульная система и есть такая корзинка.

 Модуль - это контейнер, внутрь которого вы помещаете код своего компонента, и захлопываете крышку. Только в отличие
 от герметичного стального контейнера, "стенки" модуля прозрачные, невидимые. Их словно и нет. А профит есть. Много
 профита.


Зачем это и для кого?
--------------------
Как вы связываете компоненты между собой? Например, вы объявляете на странице блок с формой авторизации,
пишете для неё  клиентский javascript-код, в котором описываете поведение формы: нажали на кнопку сабмита — отправь
авторизационные данные аяксом, а не через стандартный `form.submit()`.

И допустим, в проекте уже есть специальный компонент "кнопка", в котором реализовано всё поведение кнопки,
например, "если меня нажали, нужно что-то сделать, не знаю что - это решает другой компонент,
в который меня пригласят поработать".

То есть, ваша "форма" должна уметь найти кнопку, заполучить её внутрь себя, и слушать на ней событие клика.

Как вы определяете, что кнопка **уже готова** взаимодействовать с другими блоками?


Модульная система умеет это делать вместо вас. Она избавляет вас от головной боли отслеживать зависимости между
компонентами, поддерживать руками эти зависимости в актуальном состоянии. Это реализовано примерно как наследование,
 когда в коде компонента явно указано, от какого класса наследоваться. Только модульная система занимается не наследованием,
а зависимостями между компонентами. Ваш модуль говорит вслух: "для моей корректной работы нужен такой-то компонент".

Если вы оформляете форму в виде ymaps-модуля, вы просто декларируете зависимость от кнопки, и знаете,
что код формы будет активирован тогда, когда для этого всё готово, в частности, кнопка готова слушать на себе событие
клика. Вам не нужно самому отслеживать готовность ваших компонентов. Это делает за вас модульная система.


Как этим пользоваться?
---------------------
```
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = {};

        provide(a);
    }
);
```

В этом примере ваш собственный код  - единственная строка:
```
var a = {};
```

Всё остальное - обёртка, фантик. Именно этот фантик делает из вашего кода модуль.
Вы внутрь фантика (специальные js-конструкции) складываете нужные ингредиенты (зависимости от других
модулей), перемешиваете как вам хочется (пишете код своего компонента), фантик скручиваете и втыкаете
в бок зубочистку-флажок с именем модуля. Вы сделали модуль "форма".

Давайте посмотрим на конфету пристальнее :)

Так объявляется модуль. Позовите метод define()
```
modules.define(
);
```

Скажите модулю:"Тебя зовут `А`"
```
modules.define(
    'A'
);
```

Потом добавьте:"Вообще-то ты зависишь от модулей `В` и `С`"
```
modules.define(
    'A',
    ['B', 'C'],
);
```

Опишите код модуля в анонимной функции. В него параметрами придёт код модулей `B` и `С`,
и вы сможете их использовать внутри модуля.
```
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {

    }
);
```

Чтобы другие модули могли использовать этот модуль, пусть ваш модуль громко произнесёт вслух:
"Модуль `А` - это я!". Вы делаете это методом `provide(а)`
```
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {

        provide(a);
    }
);
```

И, наконец, напишите свой компонент. Пусть это будет что-нибудь хорошее ;)
```
modules.define(
    'A',
    ['B', 'C'],
    function(provide, b, c) {
        var a = 'yandex it is good company';

        provide(a);
    }
);
```

Всё. Сложности закончились :)

А вот как, к примеру, может выглядеть код модуля, отвечающий за форму логина. Создадим фантик,
позовём в него кнопку и что-нибудь запрограммируем внутри:
```
modules.define(
    'y-form',
    ['y-button'],
    function(provide, button) {
        var form = getElementById('my-form');
        form.on('submit', onSubmited);

        function onSubmited() {
            if ($(button).css('disabled')) {
                return false;
            }
            form.submit();
        }

        provide(form);
    }
);
```

Это выдуманный пример, он вообще нерабочий. В теле анонимной функции мы программируем поведение формы в
зависимости от того, активна или неактивна кнопка. А после этого методом provide(form) выбрасываем вверх флаг: "Форма —
 это я". Как в МасДональдсе: "Свободная касса!" И теперь все другие модули могут точно так же, как кнопку,
позвать внутрь себя модуль "форма" - благодаря методу provide, который наружу модуля выбросил флаг именем модуля.

 Возвращаясь к аналогии с конфетой, модуль - фантик (метод define с анонимной функцией внутри), на фантике написано
имя модуля и воткнута зубочистка, за которую конфетку удобно взять (метод provide). Модуль независим и
работоспособен, потому что он будет запущен только после того, как все зависимости будут предоставлены
(правильные программисты используют термины "разрезолвлены" или "разрешены") внутрь модуля.

Осталось сказать, что зависимости резолвятся асинхронно, дерево зависимостей строится в рантайме,
модули можно переопределять и доопределять. А теперь возвращаю вас к главной странице инструмента: https://github.com/ymaps/modules

Пользуйтесь на здоровье, автор инструмента желает вам успехов и не против выпить с вами вкусного коньку ;)

PS. Кстати, дерево зависимостей, построенное модульной системой, можно использовать к любом файловом сборщике,
потому что имя модуля легко мапится на имя файла,в котором этот модуль хранится. И тогда
вы ещё и собирать файлы руками не будете, всё будут делать роботы ;)


Багрепорты, сложные вопросы и благодарности присылайте на dfilatov@yandex-team.ru :)
